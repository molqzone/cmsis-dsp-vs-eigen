# 实验设计报告：Eigen 与 CMSIS-DSP 在 Cortex-M4 平台下的矩阵运算性能基准测试

## 1. 实验目的

探究在资源受限的 Cortex-M4F 嵌入式平台上，现代 C++ 模板元编程库（Eigen）与 ARM 官方手写汇编优化库（CMSIS-DSP）在不同维度矩阵运算下的性能差异，找出两者的性能临界点（Crossover Point），为嵌入式算法选型提供数据支持。

## 2. 实验平台与环境 (Experimental Setup)

为了确保测试结果仅反映算法本身的效率，必须严格固定硬件和编译环境。

### 2.1 硬件环境

* **核心架构**：ARM Cortex-M4F (带单精度 FPU)
* **目标芯片**：STM32F4xx 或 STM32G4xx 系列 (推荐主频 > 100MHz)
* **时钟配置**：
  * 系统时钟 (HCLK)：锁定最大频率 (如 168MHz/170MHz)，禁止动态调频。
  * Flash 等待周期 (Latency)：设置为该频率下的推荐值，开启预取指 (Prefetch) 和指令缓存 (I-Cache/D-Cache)。
* **运行介质**：核心测试代码放置于 `CCMRAM` (如有) 或 `SRAM` 中运行，以消除 Flash 取指不确定性的影响。

### 2.2 软件环境

* **编译器**：ST-Clang
* **优化等级**：**`-O3` (最高优化)** + Link Time Optimization (`-flto`)
  * *理由*：Eigen 极度依赖内联和循环展开，非 -O3 环境下无对比意义。
* **FPU 设置**：`-mfloat-abi=hard -mfpu=fpv4-sp-d16` (强制生成 FPU 指令)
* **C++ 标准**：`-std=c++17`

---

## 3. 实验变量设计 (Variables)

### 3.1 自变量 (Independent Variables)

1. **运算库 (Library)**：
    * **组 A (Eigen)**：使用 `Eigen::Matrix<float, N, N, RowMajor>` (定长、行优先)。
    * **组 B (CMSIS-DSP)**：使用 `arm_mat_mult_f32` 等标准 API。
2. **矩阵规模 (Matrix Size N)**：
    * **微型组**：3x3, 4x4 (典型姿态解算、机器人运动学场景)
    * **小型组**：6x6, 8x8, 10x10 (卡尔曼滤波、状态观测器场景)
    * **中型组**：16x16, 32x32 (部分信号处理、神经网络层)
    * **大型组**：64x64 (极限压力测试，考察缓存命中率)
3. **运算类型 (Operation)**：
    * 矩阵乘法 ($C = A \times B$)
    * 矩阵求逆 ($A^{-1}$，仅针对 $N \le 10$ 进行测试)

### 3.2 因变量 (Dependent Variable)

* **执行耗时 (Execution Cycles)**：以 CPU 时钟周期数为单位。

---

## 4. 变量控制与干扰排除 (Control of Variables)

这是本实验最关键的部分，用于确保“公平竞争”。

| 控制项 | 控制策略 | 原因 |
| :--- | :--- | :--- |
| **内存分配** | **全静态分配 (Stack/BSS)** | 严禁在计时区间内使用 `malloc/new`。Eigen 必须使用 `Fixed Size` 模板参数，CMSIS-DSP 输入数组需预先定义。 |
| **数据布局** | **强制行优先 (Row-Major)** | CMSIS-DSP 默认为行优先。Eigen 默认为列优先，必须在定义类型时强制指定 `Eigen::RowMajor`，避免 Eigen 内部发生隐式转置带来的额外开销。 |
| **数据随机性** | **运行时伪随机填充** | 输入矩阵必须在运行时填充非零、非单位矩阵的伪随机浮点数。防止编译器进行“常量折叠”优化（直接算出结果），或算法库对特殊矩阵（如单位阵、零阵）走快速通道。 |
| **中断干扰** | **全局关中断 (`__disable_irq`)** | 在测试区间内彻底关闭中断，防止 SysTick 或其他外设中断打断流水线和测量计数。 |
| **缓存状态** | **热缓存 (Hot Cache)** | 每个测试运行 100 次，取平均值（或取中位数）。每次运算前先空跑一次（Warm-up），确保指令已加载至 I-Cache。 |
| **测量开销** | **扣除 DWT 读指令开销** | 测量单纯执行 `Start_Timer(); Stop_Timer();` 的耗时，并在最终结果中减去此 Base Overhead。 |
| **结果有效性** | **防优化桩 (Volatile Sink)** | 计算结果必须被“使用”（如打印校验和，或赋值给 volatile 变量），防止编译器判定为死代码（Dead Code）而将整个计算过程优化删除。 |

---

## 5. 实验流程 (Procedure)

### 阶段一：准备工作

1. 初始化 MCU 时钟、FPU、UART（用于输出结果）。
2. 开启 DWT (Data Watchpoint and Trace) 计数器。
3. 实现简易伪随机数生成器（LCG算法），避免使用标准库 `rand()` 的开销。

### 阶段二：基准测试循环 (针对每个 N)

1. **数据准备**：
    * 生成两个 $N \times N$ 的源矩阵数据 $A_{data}, B_{data}$。
    * 将数据分别映射给 Eigen 对象和 CMSIS-DSP 结构体。
2. **CMSIS-DSP 测试**：
    * 关闭全局中断。
    * 重置并启动 DWT 计数器。
    * 执行 `arm_mat_mult_f32`。
    * 停止 DWT，读取计数值 $T_{cmsis}$。
    * 开启全局中断。
3. **Eigen 测试**：
    * 关闭全局中断。
    * 重置并启动 DWT 计数器。
    * 执行 `C.noalias() = A * B` (使用 `noalias()` 避免临时变量拷贝)。
    * 停止 DWT，读取计数值 $T_{eigen}$。
    * 开启全局中断。
4. **结果校验**：
    * 比较 Eigen 结果与 CMSIS-DSP 结果的欧几里得距离（误差范数）。
    * 若误差超过 `1e-4`，标记该次测试无效。
5. **循环**：
    * 上述步骤重复 100 次，记录所有数据。

---

## 6. 数据记录与分析计划

### 6.1 数据表结构

| 矩阵大小 (N) | Eigen 平均周期 | CMSIS 平均周期 | 加速比 (CMSIS/Eigen) | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| 3x3 | ... | ... | > 1.0 表示 Eigen 快 | |
| 4x4 | ... | ... | ... | |
| ... | ... | ... | ... | |

### 6.2 分析维度

1. **小矩阵优势区**：观察在 N=3, 4 时，Eigen 是否因为完全循环展开（Loop Unrolling）而显著快于 CMSIS-DSP。
2. **临界点识别**：寻找加速比曲线穿过 1.0 的 N 值。预测该点在 N=10~16 之间。
3. **大矩阵趋势**：观察 N > 30 时，CMSIS-DSP 的 SIMD 优化是否开始展现统治力。
4. **Flash 等待惩罚**：分析 Eigen 编译出的代码体积（Code Size）是否随 N 增大而剧烈膨胀，导致 Cache Miss 率上升从而拖累性能。

## 7. 预期风险与对策

* **风险**：Eigen 模板展开导致编译出的二进制文件过大，Flash 放不下。
  * **对策**：仅测试关键尺寸，避免对大矩阵使用全展开模板，大矩阵可回退到 `Dynamic` 大小进行对比测试（注明变量变更）。
* **风险**：堆栈溢出 (Stack Overflow)。
  * **对策**：在链接脚本 (`.ld` 文件) 中增大 Stack Size，或者将大型测试矩阵定义为全局静态变量 (`static`)。
